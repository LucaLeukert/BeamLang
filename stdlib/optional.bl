type Optional<T> {
    internal kind: number,
    internal tag: number,
    internal value: any,
    unwrap: fn(T?, T) -> T,
    map: fn(T?, fn(T) -> any) -> any?,
    and_then: fn(T?, fn(T) -> any?) -> any?,
    is_present: fn(T?) -> bool
}

internal fn optional_some<T>(value: T) -> T? {
    return { 
        kind = 1, 
        tag = 1, 
        value = value, 
        unwrap = optional_unwrap, 
        map = optional_map, 
        and_then = optional_and_then, 
        is_present = optional_is_present
    };
}

internal fn optional_none<T>() -> T? {
    return { 
        kind = 1, 
        tag = 0, 
        value = 0, 
        unwrap = optional_unwrap, 
        map = optional_map, 
        and_then = optional_and_then,
        is_present = optional_is_present
    };
}

internal fn optional_is_present<T>(self: T?) -> bool {
    return self->tag == 1;
}

internal fn optional_unwrap<T>(self: T?, fallback: T) -> T {
    return match (self) {
        case?some inner => inner,
        case?none => fallback
    };
}

internal fn optional_map<T, U>(self: T?, mapper: fn(T) -> U) -> U? {
    return match (self) {
        case?some inner => optional_some(mapper(inner)),
        case?none => optional_none()
    };
}

internal fn optional_and_then<T, U>(self: T?, mapper: fn(T) -> U?) -> U? {
    return match (self) {
        case?some inner => mapper(inner),
        case?none => optional_none()
    };
}

// Wrap a raw {tag, value} map into a full Optional with methods
@external(elixir, "BeamLang.Runtime", "optional_raw_tag")
fn optional_raw_tag(raw: any) -> number;

@external(elixir, "BeamLang.Runtime", "optional_raw_value")
fn optional_raw_value(raw: any) -> any;

fn wrap_optional<T>(raw: any) -> T? {
    let tag = optional_raw_tag(raw);
    if (tag == 1) {
        let value = optional_raw_value(raw);
        return optional_some(value);
    }
    return optional_none();
}
