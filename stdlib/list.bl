type List<T> {
    data: any,
    length: fn(List<T>) -> number,
    get: fn(List<T>, number) -> T?,
    push: fn(List<T>, T) -> List<T>,
    pop: fn(List<T>) -> List<T>,
    first: fn(List<T>) -> T?,
    last: fn(List<T>) -> T?,
    iter: fn(List<T>) -> Iterator<T>,
    map: fn(List<T>, fn(T) -> any) -> List<any>,
    filter: fn(List<T>, fn(T) -> bool) -> List<T>,
    fold: fn(List<T>, any, fn(any, T) -> any) -> any,
    reverse: fn(List<T>) -> List<T>,
    concat: fn(List<T>, List<T>) -> List<T>
}

@external(elixir, "BeamLang.Runtime", "list_length")
fn list_length_data(data: any) -> number;

@external(elixir, "BeamLang.Runtime", "list_get")
fn list_get_data(data: any, index: number) -> any?;

@external(elixir, "BeamLang.Runtime", "list_push")
fn list_push_data(data: any, item: any) -> any;

@external(elixir, "BeamLang.Runtime", "list_pop")
fn list_pop_data(data: any) -> any;

@external(elixir, "BeamLang.Runtime", "list_first")
fn list_first_data(data: any) -> any?;

@external(elixir, "BeamLang.Runtime", "list_last")
fn list_last_data(data: any) -> any?;

@external(elixir, "BeamLang.Runtime", "list_reverse")
fn list_reverse_data(data: any) -> any;

@external(elixir, "BeamLang.Runtime", "list_concat")
fn list_concat_data(left: any, right: any) -> any;

@external(elixir, "BeamLang.Runtime", "list_empty")
fn list_empty_data() -> any;

fn list_new() -> List<any> {
    return list_from_data(list_empty_data());
}

fn list_of(items: any) -> List<any> {
    return list_from_data(items);
}

internal fn list_from_data(data: any) -> List<any> {
    return {
        data = data,
        length = list_length_method,
        get = list_get_method,
        push = list_push_method,
        pop = list_pop_method,
        first = list_first_method,
        last = list_last_method,
        iter = list_iter_method,
        map = list_map_method,
        filter = list_filter_method,
        fold = list_fold_method,
        reverse = list_reverse_method,
        concat = list_concat_method
    };
}

internal fn list_length_method(self: List<any>) -> number {
    return list_length_data(self->data);
}

internal fn list_get_method(self: List<any>, index: number) -> any? {
    return list_get_data(self->data, index);
}

internal fn list_push_method(self: List<any>, item: any) -> List<any> {
    let new_data = list_push_data(self->data, item);
    return list_from_data(new_data);
}

internal fn list_pop_method(self: List<any>) -> List<any> {
    let new_data = list_pop_data(self->data);
    return list_from_data(new_data);
}

internal fn list_first_method(self: List<any>) -> any? {
    return list_first_data(self->data);
}

internal fn list_last_method(self: List<any>) -> any? {
    return list_last_data(self->data);
}

internal fn list_iter_method(self: List<any>) -> Iterator<any> {
    return iterator_from_list(self->data);
}

internal fn list_map_method(self: List<any>, mapper: fn(any) -> any) -> List<any> {
    let mapped = iterator_map_data(self->data, mapper);
    return list_from_data(mapped);
}

internal fn list_filter_method(self: List<any>, predicate: fn(any) -> bool) -> List<any> {
    let filtered = iterator_filter_data(self->data, predicate);
    return list_from_data(filtered);
}

internal fn list_fold_method(self: List<any>, initial: any, folder: fn(any, any) -> any) -> any {
    return iterator_fold_data(self->data, initial, folder);
}

internal fn list_reverse_method(self: List<any>) -> List<any> {
    let reversed = list_reverse_data(self->data);
    return list_from_data(reversed);
}

internal fn list_concat_method(self: List<any>, other: List<any>) -> List<any> {
    let concatenated = list_concat_data(self->data, other->data);
    return list_from_data(concatenated);
}
