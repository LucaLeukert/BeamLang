type Iterator<T> {
    data: any,
    next: fn(Iterator<T>) -> Optional<T>,
    map: fn(Iterator<T>, fn(T) -> any) -> Iterator<any>,
    filter: fn(Iterator<T>, fn(T) -> bool) -> Iterator<T>,
    fold: fn(Iterator<T>, any, fn(any, T) -> any) -> any
}

type Optional<T> {
    tag: any,
    value: any,
    unwrap: fn(Optional<T>, T) -> T,
    map: fn(Optional<T>, fn(T) -> any) -> Optional<any>,
    and_then: fn(Optional<T>, fn(T) -> Optional<any>) -> Optional<any>
}

type Result<Ok, Err> {
    tag: any,
    value: any,
    unwrap: fn(Result<Ok, Err>, Ok) -> Ok,
    map: fn(Result<Ok, Err>, fn(Ok) -> any) -> Result<any, Err>,
    and_then: fn(Result<Ok, Err>, fn(Ok) -> Result<any, Err>) -> Result<any, Err>
}

type String {
    data: any,
    length: fn(String) -> number,
    chars: fn(String) -> Iterator<char>,
    concat: fn(String, String) -> String
}

@external(elixir, "BeamLang.Runtime", "println")
fn println(value: String) -> void;

@external(elixir, "BeamLang.Runtime", "print")
fn print(value: String) -> void;

@external(elixir, "BeamLang.Runtime", "typeof_data")
fn typeof_data(value: any) -> any;

@external(elixir, "BeamLang.Runtime", "string_length_data")
fn string_length_data(value: String) -> number;

@external(elixir, "BeamLang.Runtime", "string_concat_data")
fn string_concat_data(left: String, right: String) -> String;

@external(elixir, "BeamLang.Runtime", "string_chars_data")
fn string_chars_data(value: String) -> any;

@external(elixir, "BeamLang.Runtime", "iterator_next_data")
fn iterator_next_data(data: any) -> Optional<any>;

@external(elixir, "BeamLang.Runtime", "iterator_map_data")
fn iterator_map_data(data: any, mapper: fn(any) -> any) -> any;

@external(elixir, "BeamLang.Runtime", "iterator_filter_data")
fn iterator_filter_data(data: any, predicate: fn(any) -> bool) -> any;

@external(elixir, "BeamLang.Runtime", "iterator_fold_data")
fn iterator_fold_data(data: any, initial: any, folder: fn(any, any) -> any) -> any;

fn iterator_from_list(data: any) -> Iterator<any> {
    return { data = data, next = iterator_next, map = iterator_map, filter = iterator_filter, fold = iterator_fold };
}

fn iterator_next(it: Iterator<any>) -> Optional<any> {
    let raw = iterator_next_data(it->data);
    return match (raw) {
        case?some inner => ?some inner,
        case?none => ?none
    };
}

fn iterator_map(it: Iterator<any>, mapper: fn(any) -> any) -> Iterator<any> {
    let mapped = iterator_map_data(it->data, mapper);
    return iterator_from_list(mapped);
}

fn iterator_filter(it: Iterator<any>, predicate: fn(any) -> bool) -> Iterator<any> {
    let filtered = iterator_filter_data(it->data, predicate);
    return iterator_from_list(filtered);
}

fn iterator_fold(it: Iterator<any>, initial: any, folder: fn(any, any) -> any) -> any {
    return iterator_fold_data(it->data, initial, folder);
}

fn typeof(value: any) -> String {
    let data = typeof_data(value);
    return { data = data, length = string_length, chars = string_chars, concat = string_concat };
}

internal fn string_length(value: String) -> number {
    return string_length_data(value->data);
}

internal fn string_concat(left: String, right: String) -> String {
    let data = string_concat_data(left->data, right->data);
    return { data = data, length = string_length, chars = string_chars, concat = string_concat };
}

internal fn string_chars(value: String) -> Iterator<char> {
    let data = string_chars_data(value->data);
    return iterator_from_list(data);
}

internal fn optional_unwrap(value: Optional<any>, fallback: any) -> any {
    return match (value) {
        case?some inner => inner,
        case?none => fallback
    };
}

internal fn optional_map(value: Optional<any>, mapper: fn(any) -> any) -> Optional<any> {
    return match (value) {
        case?some inner => ?some mapper(inner),
        case?none => ?none
    };
}

internal fn optional_and_then(value: Optional<any>, mapper: fn(any) -> Optional<any>) -> Optional<any> {
    return match (value) {
        case?some inner => mapper(inner),
        case?none => ?none
    };
}

internal fn result_unwrap(value: Result<any, any>, fallback: any) -> any {
    return match (value) {
        case!ok inner => inner,
        case!err _ => fallback
    };
}

internal fn result_map(value: Result<any, any>, mapper: fn(any) -> any) -> Result<any, any> {
    return match (value) {
        case!ok inner => !ok mapper(inner),
        case!err err => !err err
    };
}

internal fn result_and_then(value: Result<any, any>, mapper: fn(any) -> Result<any, any>) -> Result<any, any> {
    return match (value) {
        case!ok inner => mapper(inner),
        case!err err => !err err
    };
}
