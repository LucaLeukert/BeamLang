type Iterator<T> {
    data: any,
    next: fn(Iterator<T>) -> Optional<T>,
    map: fn(Iterator<T>, fn(T) -> any) -> Iterator<any>,
    filter: fn(Iterator<T>, fn(T) -> bool) -> Iterator<T>,
    fold: fn(Iterator<T>, any, fn(any, T) -> any) -> any
}

@external(elixir, "BeamLang.Runtime", "iterator_next_data")
fn iterator_next_data(data: any) -> Optional<any>;

@external(elixir, "BeamLang.Runtime", "iterator_map_data")
fn iterator_map_data(data: any, mapper: fn(any) -> any) -> any;

@external(elixir, "BeamLang.Runtime", "iterator_filter_data")
fn iterator_filter_data(data: any, predicate: fn(any) -> bool) -> any;

@external(elixir, "BeamLang.Runtime", "iterator_fold_data")
fn iterator_fold_data(data: any, initial: any, folder: fn(any, any) -> any) -> any;

fn iterator_from_list<T>(data: any) -> Iterator<T> {
    return { data = data, next = iterator_next, map = iterator_map, filter = iterator_filter, fold = iterator_fold };
}

fn iterator_next<T>(self: Iterator<T>) -> Optional<T> {
    let raw = iterator_next_data(self->data);
    return match (raw) {
        case?some inner => ?some inner,
        case?none => ?none
    };
}

fn iterator_map<T, U>(self: Iterator<T>, mapper: fn(T) -> U) -> Iterator<U> {
    let mapped = iterator_map_data(self->data, mapper);
    return iterator_from_list(mapped);
}

fn iterator_filter<T>(self: Iterator<T>, predicate: fn(T) -> bool) -> Iterator<T> {
    let filtered = iterator_filter_data(self->data, predicate);
    return iterator_from_list(filtered);
}

fn iterator_fold<T, U>(self: Iterator<T>, initial: U, folder: fn(U, T) -> U) -> U {
    return iterator_fold_data(self->data, initial, folder);
}
