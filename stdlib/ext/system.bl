// System utilities for file and process operations

// Error type for IO operations
export error IoError {
    kind: String,
    message: String
}

// Type for file system entries
export type FileEntry {
    name: String,
    is_dir: bool,
    size: number
}

export type Path {
    internal is_absolute: bool,
    segments: [String],
    operator /: fn(Path, String) -> Path,
    push: fn(Path, String) -> Path,
    to_string: fn(Path) -> String
}

export type Clock {
    internal start_time: number,
    internal stop_time: number,
    start: fn(Clock) -> Clock,
    stop: fn(Clock) -> Clock,
    elapsed: fn(Clock) -> number,
    now: fn(Clock) -> number
}

@external(elixir, "BeamLang.Runtime", "file_read")
fn file_read_data(path: String) -> String!String;

@external(elixir, "BeamLang.Runtime", "file_write")
fn file_write_data(path: String, contents: String) -> bool!String;

@external(elixir, "BeamLang.Runtime", "file_exists")
fn file_exists_data(path: String) -> bool;

@external(elixir, "BeamLang.Runtime", "read_stdin")
fn read_stdin_data() -> String;

@external(elixir, "BeamLang.Runtime", "get_env")
fn get_env_data(name: String) -> any;

@external(elixir, "BeamLang.Runtime", "clock_now")
fn clock_now_data() -> number;

@external(elixir, "BeamLang.Runtime", "list_directory")
fn list_directory_data(path: String) -> List<FileEntry>!String;

internal fn file_entry_new(name: String, is_dir: bool, size: number) -> FileEntry {
    return {
        name = name,
        is_dir = is_dir,
        size = size
    };
}

internal fn make_io_error(msg: String) -> IoError {
    let err: IoError = { kind = "read", message = msg };
    return err;
}

internal fn path_from_parts(is_absolute: bool, segments: [String]) -> Path {
    return {
        is_absolute = is_absolute,
        segments = segments,
        operator / = path_div_method,
        push = path_push_method,
        to_string = path_to_string_method
    };
}

internal fn path_normalize_segment(segment: String) -> [String] {
    let raw = segment->split("/");

    return raw->filter(fn(item: String) -> bool {
        let cleaned = item->trim();
        return cleaned != "";
    });
}

internal fn path_push_method(self: Path, segment: String) -> Path {
    let normalized = path_normalize_segment(segment);
    let next_segments = self->segments->concat(normalized);
    return path_from_parts(self->is_absolute, next_segments);
}

internal fn path_div_method(self: Path, segment: String) -> Path {
    return self->push(segment);
}

internal fn path_to_string_method(self: Path) -> String {
    let body = self->segments->join("/");

    if (self->is_absolute) {
        return "/"->concat(body);
    }

    return body;
}

internal fn clock_now_method(self: Clock) -> number {
    return clock_now_data();
}

internal fn clock_start_method(mut self: Clock) -> Clock {
    self->start_time = clock_now_data();
    return self;
}

internal fn clock_stop_method(mut self: Clock) -> Clock {
    self->stop_time = clock_now_data();
    return self;
}

internal fn clock_elapsed_method(self: Clock) -> number {
    return self->stop_time - self->start_time;
}

/** Create a new Clock instance **/
fn clock_new() -> Clock {
    return {
        start_time = 0,
        stop_time = 0,
        start = clock_start_method,
        stop = clock_stop_method,
        elapsed = clock_elapsed_method,
        now = clock_now_method
    };
}

/** Get current monotonic time in milliseconds **/
fn clock_now() -> number {
    return clock_now_data();
}

/** Create an empty Path **/
fn path_new() -> Path {
    let empty: [String] = [];
    return path_from_parts(false, empty);
}

/** Create a Path from a slash-separated string **/
fn path_from_string(raw: String) -> Path {
    let is_absolute = raw->starts_with("/");
    let normalized = path_normalize_segment(raw);
    return path_from_parts(is_absolute, normalized);
}

/** Read a file and return its contents as a Result **/
fn read_file(path: Path) -> String!IoError {
    let path_text = path->to_string();
    let result = file_read_data(path_text);
    return match (result) {
        case!ok content => !ok content,
        case!err msg => !err make_io_error(msg)
    };
}

/** Write a file and return a Result **/
fn write_file(path: Path, contents: String) -> bool!IoError {
    let path_text = path->to_string();
    let result = file_write_data(path_text, contents);
    return match (result) {
        case!ok ok => !ok ok,
        case!err msg => !err make_io_error(msg)
    };
}

/** Check if a file exists **/
fn file_exists(path: Path) -> bool {
    let path_text = path->to_string();
    return file_exists_data(path_text);
}

/** Read all data from stdin **/
fn read_stdin() -> String {
    return read_stdin_data();
}

/** Get an environment variable, returns None if not set **/
fn get_env(name: String) -> String? {
    return get_env_data(name);
}

/** List the contents of a directory **/
fn list_directory(path: Path) -> List<FileEntry>!IoError {
    let path_text = path->to_string();
    let result = list_directory_data(path_text);
    return match (result) {
        case!ok entries => !ok entries,
        case!err msg => !err make_io_error(msg)
    };
}
