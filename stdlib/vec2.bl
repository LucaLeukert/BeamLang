// 2D Vector type with operator overloading

type Vec2 {
    x: number,
    y: number,
    length: fn(Vec2) -> number,
    normalize: fn(Vec2) -> Vec2,
    dot: fn(Vec2, Vec2) -> number,
    operator +: fn(Vec2, Vec2) -> Vec2,
    operator -: fn(Vec2, Vec2) -> Vec2,
    operator *: fn(Vec2, number) -> Vec2,
    operator /: fn(Vec2, number) -> Vec2,
    operator ==: fn(Vec2, Vec2) -> bool,
    operator !=: fn(Vec2, Vec2) -> bool
}

@external(elixir, "BeamLang.Runtime", "math_sqrt")
fn sqrt(n: number) -> number;

fn vec2(x: number, y: number) -> Vec2 {
    return {
        x = x,
        y = y,
        length = vec2_length,
        normalize = vec2_normalize,
        dot = vec2_dot,
        operator + = vec2_add,
        operator - = vec2_sub,
        operator * = vec2_scale,
        operator / = vec2_div,
        operator == = vec2_eq,
        operator != = vec2_neq
    };
}

fn vec2_zero() -> Vec2 {
    return vec2(0.0, 0.0);
}

fn vec2_one() -> Vec2 {
    return vec2(1.0, 1.0);
}

fn vec2_up() -> Vec2 {
    return vec2(0.0, 1.0);
}

fn vec2_right() -> Vec2 {
    return vec2(1.0, 0.0);
}

fn vec2_add(a: Vec2, b: Vec2) -> Vec2 {
    return vec2(a->x + b->x, a->y + b->y);
}

fn vec2_sub(a: Vec2, b: Vec2) -> Vec2 {
    return vec2(a->x - b->x, a->y - b->y);
}

fn vec2_scale(v: Vec2, s: number) -> Vec2 {
    return vec2(v->x * s, v->y * s);
}

fn vec2_div(v: Vec2, s: number) -> Vec2 {
    return vec2(v->x / s, v->y / s);
}

fn vec2_eq(a: Vec2, b: Vec2) -> bool {
    return match (a->x == b->x) {
        case true => a->y == b->y,
        case false => false
    };
}

fn vec2_neq(a: Vec2, b: Vec2) -> bool {
    return match (a->x != b->x) {
        case true => true,
        case false => a->y != b->y
    };
}

fn vec2_length(self: Vec2) -> number {
    return sqrt(self->x * self->x + self->y * self->y);
}

fn vec2_normalize(self: Vec2) -> Vec2 {
    let len = self->length();
    return match (len == 0.0) {
        case true => vec2_zero(),
        case false => self / len
    };
}

fn vec2_dot(self: Vec2, b: Vec2) -> number {
    return self->x * b->x + self->y * b->y;
}

fn vec2_distance(a: Vec2, b: Vec2) -> number {
    return (b - a)->length();
}

fn vec2_lerp(a: Vec2, b: Vec2, t: number) -> Vec2 {
    return a + (b - a) * t;
}
