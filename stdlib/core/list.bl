type List<T> {
    internal data: any,
    length: fn(List<T>) -> number,
    get: fn(List<T>, number) -> T?,
    push: fn(List<T>, T) -> List<T>,
    pop: fn(List<T>) -> List<T>,
    first: fn(List<T>) -> T?,
    last: fn(List<T>) -> T?,
    map: fn(List<T>, fn(T) -> any) -> List<any>,
    filter: fn(List<T>, fn(T) -> bool) -> List<T>,
    fold: fn(List<T>, any, fn(any, T) -> any) -> any,
    for_each: fn(List<T>, fn(T) -> void) -> void,
    reverse: fn(List<T>) -> List<T>,
    concat: fn(List<T>, List<T>) -> List<T>,
    join: fn(List<T>, String) -> String
}

@external(erlang, "erlang", "length")
fn list_length_data(data: any) -> number;

@external(erlang, "lists", "nth")
fn list_nth_data(index: number, data: any) -> any;

@external(elixir, "BeamLang.Runtime", "list_push")
fn list_push_data(data: any, item: any) -> any;

@external(erlang, "lists", "reverse")
fn list_reverse_data(data: any) -> any;

@external(erlang, "lists", "append")
fn list_concat_data(left: any, right: any) -> any;

@external(elixir, "BeamLang.Runtime", "list_empty")
fn list_empty_data() -> any;

internal fn list_new<T>() -> List<T> {
    return list_from_data(list_empty_data());
}

internal fn list_of<T>(items: [T]) -> List<T> {
    return list_from_data(items);
}

internal fn list_from_data<T>(data: any) -> List<T> {
    return {
        data = data,
        length = fn(self: List<T>) -> number {
            return list_length_data(self->data);
        },
        get = fn(self: List<T>, index: number) -> T? {
            return list_get_optional(self->data, index);
        },
        push = fn(self: List<T>, item: T) -> List<T> {
            let new_data = list_push_data(self->data, item);
            return list_from_data(new_data);
        },
        pop = fn(self: List<T>) -> List<T> {
            let len = self->length();
            if (len <= 0) {
                return self;
            }
            let mut acc: List<T> = list_new();
            let mut idx = 0;
            while (idx < len - 1) {
                let item = list_get_unchecked(self->data, idx);
                acc = acc->push(item);
                idx = idx + 1;
            }
            return acc;
        },
        first = fn(self: List<T>) -> T? {
            return self->get(0);
        },
        last = fn(self: List<T>) -> T? {
            let len = self->length();
            if (len <= 0) {
                return optional_none();
            }
            return self->get(len - 1);
        },
        map = fn(self: List<T>, mapper: fn(T) -> any) -> List<any> {
            let mut acc: List<any> = list_new();
            let mut idx = 0;
            let len = self->length();
            while (idx < len) {
                let item = list_get_unchecked(self->data, idx);
                acc = acc->push(mapper(item));
                idx = idx + 1;
            }
            return acc;
        },
        filter = fn(self: List<T>, predicate: fn(T) -> bool) -> List<T> {
            let mut acc: List<T> = list_new();
            let mut idx = 0;
            let len = self->length();
            while (idx < len) {
                let item = list_get_unchecked(self->data, idx);
                if (predicate(item)) {
                    acc = acc->push(item);
                }
                idx = idx + 1;
            }
            return acc;
        },
        fold = fn(self: List<T>, initial: any, folder: fn(any, T) -> any) -> any {
            let mut acc = initial;
            let mut idx = 0;
            let len = self->length();
            while (idx < len) {
                let item = list_get_unchecked(self->data, idx);
                acc = folder(acc, item);
                idx = idx + 1;
            }
            return acc;
        },
        for_each = fn(self: List<T>, callback: fn(T) -> void) -> void {
            let mut idx = 0;
            let len = self->length();
            while (idx < len) {
                let item = list_get_unchecked(self->data, idx);
                callback(item);
                idx = idx + 1;
            }
            return;
        },
        reverse = fn(self: List<T>) -> List<T> {
            let reversed = list_reverse_data(self->data);
            return list_from_data(reversed);
        },
        concat = fn(self: List<T>, other: List<T>) -> List<T> {
            let concatenated = list_concat_data(self->data, other->data);
            return list_from_data(concatenated);
        },
        join = fn(self: List<T>, separator: String) -> String {
            let mut result = "";
            let mut idx = 0;
            let len = self->length();
            while (idx < len) {
                let item = list_get_unchecked(self->data, idx);
                if (idx > 0) {
                    result = result->concat(separator);
                }
                result = result->concat(to_string(item));
                idx = idx + 1;
            }
            return result;
        }
    };
}

internal fn list_get_optional<T>(data: any, index: number) -> T? {
    if (index < 0) {
        return optional_none();
    }
    let len = list_length_data(data);
    if (index >= len) {
        return optional_none();
    }
    let value = list_nth_data(index + 1, data);
    return optional_some(value);
}

internal fn list_get_unchecked<T>(data: any, index: number) -> T {
    return list_nth_data(index + 1, data);
}
