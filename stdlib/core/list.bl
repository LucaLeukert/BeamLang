type List<T> {
    internal data: any,
    length: fn(List<T>) -> number,
    get: fn(List<T>, number) -> T?,
    push: fn(List<T>, T) -> List<T>,
    pop: fn(List<T>) -> List<T>,
    first: fn(List<T>) -> T?,
    last: fn(List<T>) -> T?,
    map: fn(List<T>, fn(T) -> any) -> List<any>,
    filter: fn(List<T>, fn(T) -> bool) -> List<T>,
    fold: fn(List<T>, any, fn(any, T) -> any) -> any,
    for_each: fn(List<T>, fn(T) -> void) -> void,
    reverse: fn(List<T>) -> List<T>,
    concat: fn(List<T>, List<T>) -> List<T>,
    join: fn(List<T>, String) -> String
}

@external(erlang, "erlang", "length")
fn list_length_data(data: any) -> number;

@external(elixir, "BeamLang.Runtime", "list_get")
fn list_get_data(data: any, index: number) -> any?;

@external(elixir, "BeamLang.Runtime", "list_push")
fn list_push_data(data: any, item: any) -> any;

@external(elixir, "BeamLang.Runtime", "list_pop")
fn list_pop_data(data: any) -> any;

@external(elixir, "BeamLang.Runtime", "list_first")
fn list_first_data(data: any) -> any?;

@external(elixir, "BeamLang.Runtime", "list_last")
fn list_last_data(data: any) -> any?;

@external(erlang, "lists", "reverse")
fn list_reverse_data(data: any) -> any;

@external(erlang, "lists", "append")
fn list_concat_data(left: any, right: any) -> any;

@external(elixir, "BeamLang.Runtime", "list_empty")
fn list_empty_data() -> any;

@external(elixir, "BeamLang.Runtime", "list_for_each")
fn list_for_each_data(data: any, callback: fn(any) -> void) -> void;

@external(elixir, "BeamLang.Runtime", "list_join")
fn list_join_data(data: any, separator: String) -> String;

@external(elixir, "BeamLang.Runtime", "list_map")
fn list_map_data(data: any, mapper: fn(any) -> any) -> any;

@external(elixir, "BeamLang.Runtime", "list_filter")
fn list_filter_data(data: any, predicate: fn(any) -> bool) -> any;

@external(elixir, "BeamLang.Runtime", "list_fold")
fn list_fold_data(data: any, initial: any, folder: fn(any, any) -> any) -> any;

fn list_new<T>() -> List<T> {
    return list_from_data(list_empty_data());
}

fn list_of<T>(items: [T]) -> List<T> {
    return list_from_data(items);
}

fn list_from_data<T>(data: any) -> List<T> {
    return {
        data = data,
        length = list_length_method,
        get = list_get_method,
        push = list_push_method,
        pop = list_pop_method,
        first = list_first_method,
        last = list_last_method,
        map = list_map_method,
        filter = list_filter_method,
        fold = list_fold_method,
        for_each = list_for_each_method,
        reverse = list_reverse_method,
        concat = list_concat_method,
        join = list_join_method
    };
}

internal fn list_length_method<T>(self: List<T>) -> number {
    return list_length_data(self->data);
}

internal fn list_get_method<T>(self: List<T>, index: number) -> T? {
    let raw = list_get_data(self->data, index);
    return wrap_optional(raw);
}

internal fn list_push_method<T>(self: List<T>, item: T) -> List<T> {
    let new_data = list_push_data(self->data, item);
    return list_from_data(new_data);
}

internal fn list_pop_method<T>(self: List<T>) -> List<T> {
    let new_data = list_pop_data(self->data);
    return list_from_data(new_data);
}

internal fn list_first_method<T>(self: List<T>) -> T? {
    let raw = list_first_data(self->data);
    return wrap_optional(raw);
}

internal fn list_last_method<T>(self: List<T>) -> T? {
    let raw = list_last_data(self->data);
    return wrap_optional(raw);
}

internal fn list_map_method<T, U>(self: List<T>, mapper: fn(T) -> U) -> List<U> {
    let mapped = list_map_data(self->data, mapper);
    return list_from_data(mapped);
}

internal fn list_filter_method<T>(self: List<T>, predicate: fn(T) -> bool) -> List<T> {
    let filtered = list_filter_data(self->data, predicate);
    return list_from_data(filtered);
}

internal fn list_fold_method<T, U>(self: List<T>, initial: U, folder: fn(U, T) -> U) -> U {
    return list_fold_data(self->data, initial, folder);
}

internal fn list_for_each_method<T>(self: List<T>, callback: fn(T) -> void) -> void {
    list_for_each_data(self->data, callback);
    return;
}

internal fn list_reverse_method<T>(self: List<T>) -> List<T> {
    let reversed = list_reverse_data(self->data);
    return list_from_data(reversed);
}

internal fn list_concat_method<T>(self: List<T>, other: List<T>) -> List<T> {
    let concatenated = list_concat_data(self->data, other->data);
    return list_from_data(concatenated);
}

internal fn list_join_method<T>(self: List<T>, separator: String) -> String {
    let result = list_join_data(self->data, separator);
    return result;
}