type List<T> {
    internal data: any,
    length: fn(List<T>) -> number,
    get: fn(List<T>, number) -> T?,
    push: fn(List<T>, T) -> List<T>,
    pop: fn(List<T>) -> List<T>,
    first: fn(List<T>) -> T?,
    last: fn(List<T>) -> T?,
    map: fn(List<T>, fn(T) -> any) -> List<any>,
    filter: fn(List<T>, fn(T) -> bool) -> List<T>,
    fold: fn(List<T>, any, fn(any, T) -> any) -> any,
    for_each: fn(List<T>, fn(T) -> void) -> void,
    reverse: fn(List<T>) -> List<T>,
    concat: fn(List<T>, List<T>) -> List<T>,
    join: fn(List<T>, String) -> String
}

@external(erlang, "erlang", "length")
fn list_length_data(data: any) -> number;

@external(elixir, "BeamLang.Runtime", "list_get")
fn list_get_data(data: any, index: number) -> any?;

@external(elixir, "BeamLang.Runtime", "list_push")
fn list_push_data(data: any, item: any) -> any;

@external(elixir, "BeamLang.Runtime", "list_pop")
fn list_pop_data(data: any) -> any;

@external(elixir, "BeamLang.Runtime", "list_first")
fn list_first_data(data: any) -> any?;

@external(elixir, "BeamLang.Runtime", "list_last")
fn list_last_data(data: any) -> any?;

@external(erlang, "lists", "reverse")
fn list_reverse_data(data: any) -> any;

@external(erlang, "lists", "append")
fn list_concat_data(left: any, right: any) -> any;

@external(elixir, "BeamLang.Runtime", "list_empty")
fn list_empty_data() -> any;

@external(elixir, "BeamLang.Runtime", "list_for_each")
fn list_for_each_data(data: any, callback: fn(any) -> void) -> void;

@external(elixir, "BeamLang.Runtime", "list_join")
fn list_join_data(data: any, separator: String) -> String;

@external(elixir, "BeamLang.Runtime", "list_map")
fn list_map_data(data: any, mapper: fn(any) -> any) -> any;

@external(elixir, "BeamLang.Runtime", "list_filter")
fn list_filter_data(data: any, predicate: fn(any) -> bool) -> any;

@external(elixir, "BeamLang.Runtime", "list_fold")
fn list_fold_data(data: any, initial: any, folder: fn(any, any) -> any) -> any;

internal fn list_new<T>() -> List<T> {
    return list_from_data(list_empty_data());
}

internal fn list_of<T>(items: [T]) -> List<T> {
    return list_from_data(items);
}

internal fn list_from_data<T>(data: any) -> List<T> {
    return {
        data = data,
        length = fn(self: List<T>) -> number {
            return list_length_data(self->data);
        },
        get = fn(self: List<T>, index: number) -> T? {
            let raw = list_get_data(self->data, index);
            return wrap_optional(raw);
        },
        push = fn(self: List<T>, item: T) -> List<T> {
            let new_data = list_push_data(self->data, item);
            return list_from_data(new_data);
        },
        pop = fn(self: List<T>) -> List<T> {
            let new_data = list_pop_data(self->data);
            return list_from_data(new_data);
        },
        first = fn(self: List<T>) -> T? {
            let raw = list_first_data(self->data);
            return wrap_optional(raw);
        },
        last = fn(self: List<T>) -> T? {
            let raw = list_last_data(self->data);
            return wrap_optional(raw);
        },
        map = fn(self: List<T>, mapper: fn(T) -> any) -> List<any> {
            let mapped = list_map_data(self->data, mapper);
            return list_from_data(mapped);
        },
        filter = fn(self: List<T>, predicate: fn(T) -> bool) -> List<T> {
            let filtered = list_filter_data(self->data, predicate);
            return list_from_data(filtered);
        },
        fold = fn(self: List<T>, initial: any, folder: fn(any, T) -> any) -> any {
            return list_fold_data(self->data, initial, folder);
        },
        for_each = fn(self: List<T>, callback: fn(T) -> void) -> void {
            list_for_each_data(self->data, callback);
            return;
        },
        reverse = fn(self: List<T>) -> List<T> {
            let reversed = list_reverse_data(self->data);
            return list_from_data(reversed);
        },
        concat = fn(self: List<T>, other: List<T>) -> List<T> {
            let concatenated = list_concat_data(self->data, other->data);
            return list_from_data(concatenated);
        },
        join = fn(self: List<T>, separator: String) -> String {
            let result = list_join_data(self->data, separator);
            return result;
        }
    };
}
