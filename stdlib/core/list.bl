type List<T> {
    internal data: any,
    length: fn(List<T>) -> number,
    get: fn(List<T>, number) -> T?,
    push: fn(List<T>, T) -> List<T>,
    pop: fn(List<T>) -> List<T>,
    first: fn(List<T>) -> T?,
    last: fn(List<T>) -> T?,
    map: fn(List<T>, fn(T) -> any) -> List<any>,
    filter: fn(List<T>, fn(T) -> bool) -> List<T>,
    fold: fn(List<T>, any, fn(any, T) -> any) -> any,
    for_each: fn(List<T>, fn(T) -> void) -> void,
    reverse: fn(List<T>) -> List<T>,
    concat: fn(List<T>, List<T>) -> List<T>,
    join: fn(List<T>, String) -> String
}

@external(erlang, "erlang", "length")
fn list_length_data(data: any) -> number;

@external(erlang, "lists", "nth")
fn list_nth_data(index: number, data: any) -> any;

@external(elixir, "BeamLang.Runtime", "list_push")
fn list_push_data(data: any, item: any) -> any;

@external(erlang, "lists", "reverse")
fn list_reverse_data(data: any) -> any;

@external(erlang, "lists", "append")
fn list_concat_data(left: any, right: any) -> any;

@external(elixir, "BeamLang.Runtime", "list_empty")
fn list_empty_data() -> any;

internal fn list_new<T>() -> List<T> {
    return list_from_data(list_empty_data());
}

internal fn list_of<T>(items: [T]) -> List<T> {
    return list_from_data(items);
}

internal fn list_from_data<T>(data: any) -> List<T> {
    return {
        data = data,
        length = list_length_method,
        get = list_get_method,
        push = list_push_method,
        pop = list_pop_method,
        first = list_first_method,
        last = list_last_method,
        map = list_map_method,
        filter = list_filter_method,
        fold = list_fold_method,
        for_each = list_for_each_method,
        reverse = list_reverse_method,
        concat = list_concat_method,
        join = list_join_method
    };
}

internal fn list_length_method<T>(self: List<T>) -> number {
    return list_length_data(self->data);
}

internal fn list_get_method<T>(self: List<T>, index: number) -> T? {
    return list_get_optional(self->data, index);
}

internal fn list_push_method<T>(self: List<T>, item: T) -> List<T> {
    let new_data = list_push_data(self->data, item);
    return list_from_data(new_data);
}

internal fn list_pop_method<T>(self: List<T>) -> List<T> {
    let len = self->length();
    if (len <= 0) {
        return self;
    }
    let mut acc: List<T> = list_new();
    let mut idx = 0;
    while (idx < len - 1) {
        let item = list_get_unchecked(self->data, idx);
        acc = acc->push(item);
        idx = idx + 1;
    }
    return acc;
}

internal fn list_first_method<T>(self: List<T>) -> T? {
    return self->get(0);
}

internal fn list_last_method<T>(self: List<T>) -> T? {
    let len = self->length();
    if (len <= 0) {
        return optional_none();
    }
    return self->get(len - 1);
}

internal fn list_map_method<T, U>(self: List<T>, mapper: fn(T) -> U) -> List<U> {
    let mut acc: List<U> = list_new();
    let mut idx = 0;
    let len = self->length();
    while (idx < len) {
        let item = list_get_unchecked(self->data, idx);
        acc = acc->push(mapper(item));
        idx = idx + 1;
    }
    return acc;
}

internal fn list_filter_method<T>(self: List<T>, predicate: fn(T) -> bool) -> List<T> {
    let mut acc: List<T> = list_new();
    let mut idx = 0;
    let len = self->length();
    while (idx < len) {
        let item = list_get_unchecked(self->data, idx);
        if (predicate(item)) {
            acc = acc->push(item);
        }
        idx = idx + 1;
    }
    return acc;
}

internal fn list_fold_method<T, U>(self: List<T>, initial: U, folder: fn(U, T) -> U) -> U {
    let mut acc = initial;
    let mut idx = 0;
    let len = self->length();
    while (idx < len) {
        let item = list_get_unchecked(self->data, idx);
        acc = folder(acc, item);
        idx = idx + 1;
    }
    return acc;
}

internal fn list_for_each_method<T>(self: List<T>, callback: fn(T) -> void) -> void {
    let mut idx = 0;
    let len = self->length();
    while (idx < len) {
        let item = list_get_unchecked(self->data, idx);
        callback(item);
        idx = idx + 1;
    }
    return;
}

internal fn list_reverse_method<T>(self: List<T>) -> List<T> {
    let reversed = list_reverse_data(self->data);
    return list_from_data(reversed);
}

internal fn list_concat_method<T>(self: List<T>, other: List<T>) -> List<T> {
    let concatenated = list_concat_data(self->data, other->data);
    return list_from_data(concatenated);
}

internal fn list_join_method<T>(self: List<T>, separator: String) -> String {
    let mut result = "";
    let mut idx = 0;
    let len = self->length();
    while (idx < len) {
        let item = list_get_unchecked(self->data, idx);
        if (idx > 0) {
            result = result->concat(separator);
        }
        result = result->concat(to_string(item));
        idx = idx + 1;
    }
    return result;
}

internal fn list_get_optional<T>(data: any, index: number) -> T? {
    if (index < 0) {
        return optional_none();
    }
    let len = list_length_data(data);
    if (index >= len) {
        return optional_none();
    }
    let value = list_nth_data(index + 1, data);
    return optional_some(value);
}

internal fn list_get_unchecked<T>(data: any, index: number) -> T {
    return list_nth_data(index + 1, data);
}
