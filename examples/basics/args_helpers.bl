// Example demonstrating the pure-BeamLang argument parsing helpers.
//
// Usage: beamlang args_helpers.bl [OPTIONS] <file> [more...]
//   --verbose / -v    verbose flag
//   --count=N / -n N  count option
//   --                separator (rest is positional)
//
// Try:
//   beamlang args_helpers.bl hello.txt --verbose -n 5
//   beamlang args_helpers.bl --count=3 hello.txt -- --not-a-flag

import args.*;
//   beamlang args_helpers.bl -h

fn main(args: [String]) -> number {
    // 1. Check for --help / -h
    if (has_help_flag(args)) {
        let names: [String] = ["file"];
        let header = format_usage_header("args_helpers", true, names);
        println(header);
        println("");
        println("Options:");
        println(format_opt_line("v", "verbose", "", "Enable verbose output"));
        println(format_opt_line("n", "count", "NUMBER", "Number of items"));
        println(format_opt_line("h", "help", "", "Show this help message"));
        println("");
        println("Arguments:");
        println(format_pos_line("file", "STRING", true, "Input file to process"));
        return 0;
    }

    // 2. Check boolean flags
    let verbose = find_flag(args, "verbose", "v");
    println("verbose: ${verbose}");

    // 3. Find named option values
    let count_str = find_option(args, "count", "n");
    let count = count_str->unwrap("10");
    println("count: ${count}");

    // 4. Split at -- separator
    let split = split_at_separator(args);
    println("before --: ${split->before->length()} args");
    println("after  --: ${split->after->length()} args");

    // 5. Collect positional arguments
    let pos = positional_args(args);
    println("positional: ${pos->length()} args");
    pos->for_each(fn(arg: String) -> void {
        println("  ${arg}");
    });

    // 6. Parse individual flags
    let test_long = parse_long_opt("--count=42");
    match (test_long) {
        case?some flag -> {
            println("parsed long: name=${flag->name} value=${flag->value} has_value=${flag->has_value}");
        },
        case?none => println("not a long opt")
    };

    let test_short = parse_short_opt("-n5");
    match (test_short) {
        case?some flag -> {
            println("parsed short: name=${flag->name} value=${flag->value} has_value=${flag->has_value}");
        },
        case?none => println("not a short opt")
    };

    // 7. Combined flags
    let combined = parse_combined_flags("-inv");
    println("combined flags: ${combined->length()}");
    combined->for_each(fn(c: String) -> void {
        println("  -${c}");
    });

    return 0;
}
