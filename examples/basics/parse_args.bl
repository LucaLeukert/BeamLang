// Example demonstrating parse_args<T>(args) with field annotations
//
// Field annotations:
//   @required()      - Field must be provided (error if missing)
//   @default(value)  - Default value when not provided
//   @description("") - Help text description for the field
//   @short("c")      - Short flag form, e.g., -c
//   @long("config")  - Long flag form, e.g., --config
//   @flag            - Boolean flag (presence = true, absence = false)

import args.*;

type Args {
    @required()
    @description("Path to the file")
    path: String,

    @flag
    @short("e")
    @long("enabled")
    @description("Enable the feature")
    enabled: bool,

    @short("c")
    @long("count")
    @default(1)
    @description("Number of iterations")
    count: number
}

fn main(args: [String]) -> number {
    let parsed = parse_args<Args>(args);

    return match (parsed) {
        case!ok opts => {
            println("Path: ${opts->path}");
            println("Enabled: ${opts->enabled}");
            println("Count: ${opts->count}");
            0;
        },
        case!err err => {
            println("Usage: parse_args <path> [-e|--enabled] [-c|--count <n>]");
            println("");
            println("Error: ${err->message}");
            println("Missing fields: ${err->missing->length()}");
            1;
        }
    };
}
