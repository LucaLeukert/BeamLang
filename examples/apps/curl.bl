// curl - fetch URLs over HTTP
// Usage: beamlang curl.bl [OPTIONS] <url>
//
// Basic features:
// - Set method (-X)
// - Send data (-d)
// - Add headers (-H, comma-separated)
// - Write output to file (-o)
// - Follow redirects (-L)
// - Include headers (-i)
// - Head request (-I)
// - Silent errors (-s)

import args.*;
import system.*;
import network.*;

type Args {
    @required()
    @description("URL to fetch")
    url: String,

    @default("")
    @short("X")
    @long("request")
    @description("Request method (GET, POST, PUT, ...)")
    request: String,

    @default("")
    @short("d")
    @long("data")
    @description("Request body data")
    data: String,

    @default("")
    @short("H")
    @long("header")
    @description("Headers, comma-separated (e.g. \"A:1,B:2\")")
    header: String,

    @default("")
    @short("o")
    @long("output")
    @description("Write response body to file")
    output: String,

    @default("")
    @short("A")
    @long("user-agent")
    @description("User-Agent header value")
    user_agent: String,

    @default(30)
    @long("max-time")
    @description("Timeout in seconds")
    max_time: number,

    @flag
    @short("I")
    @long("head")
    @description("Fetch headers only")
    head_only: bool,

    @flag
    @short("L")
    @long("location")
    @description("Follow redirects")
    follow: bool,

    @flag
    @short("i")
    @long("include")
    @description("Include response headers in output")
    include_headers: bool,

    @flag
    @short("s")
    @long("silent")
    @description("Suppress error output")
    silent: bool
}

fn is_non_empty(value: String) -> bool {
    let trimmed = value->trim();
    return trimmed->length() > 0;
}

fn trim_header(value: String) -> String {
    return value->trim();
}

fn split_headers(header_text: String) -> [String] {
    let trimmed = header_text->trim();
    if (trimmed->length() == 0) {
        return [];
    }
    let parts = trimmed->split(",");
    let cleaned = parts->map(trim_header);
    return cleaned->filter(is_non_empty);
}

fn add_user_agent(headers: [String], user_agent: String) -> [String] {
    let trimmed = user_agent->trim();
    if (trimmed->length() == 0) {
        return headers;
    }
    let prefix = "User-Agent: ";
    let value = prefix->concat(trimmed);
    return headers->push(value);
}

fn resolve_method(opts: Args) -> String {
    if (opts->head_only) {
        return "HEAD";
    }
    let req = opts->request->trim();
    if (req->length() > 0) {
        return req->to_upper();
    }
    let data_trimmed = opts->data->trim();
    if (data_trimmed->length() > 0) {
        return "POST";
    }
    return "GET";
}

fn should_show_headers(opts: Args) -> bool {
    if (opts->head_only) {
        return true;
    }
    if (opts->include_headers) {
        return true;
    }
    return false;
}

fn print_headers(status: number, headers: [String], include_blank: bool) -> void {
    println("HTTP ${status}");
    let header_text = headers->join("\n");
    if (header_text->length() > 0) {
        println(header_text);
    }
    if (include_blank) {
        println("");
    }
}

fn write_output(path: String, content: String, silent: bool) -> number {
    let result = write_file(path, content);
    return match (result) {
        case!ok _ => 0,
        case!err err -> {
            if (silent == false) {
                println("curl: ${err->message}");
            }
            1;
        }
    };
}

fn output_body(opts: Args, body: String) -> number {
    let out_trimmed = opts->output->trim();
    if (out_trimmed->length() > 0) {
        return write_output(opts->output, body, opts->silent);
    }
    print(body);
    return 0;
}

fn handle_response(resp: HttpResponse, opts: Args) -> number {
    if (should_show_headers(opts)) {
        let include_blank = if (opts->include_headers) { opts->head_only == false; } else { false; };
        print_headers(resp->status, resp->headers, include_blank);
        if (opts->head_only) {
            return 0;
        }
    }
    return output_body(opts, resp->body);
}

fn run_curl(opts: Args) -> number {
    let headers = split_headers(opts->header);
    let headers_with_ua = add_user_agent(headers, opts->user_agent);
    let method = resolve_method(opts);
    let timeout_ms = opts->max_time * 1000;
    let result = http_request(method, opts->url, headers_with_ua, opts->data, timeout_ms, opts->follow);

    return match (result) {
        case!ok resp => handle_response(resp, opts),
        case!err err -> {
            if (opts->silent == false) {
                println("curl: ${err->message}");
            }
            1;
        }
    };
}

fn print_usage() -> void {
    let help = usage<Args>("curl");
    println(help);
}

fn main(args: [String]) -> number {
    let parsed = parse_args<Args>(args);

    return match (parsed) {
        case!ok opts => run_curl(opts),
        case!err err -> {
            if (err->message == "--help") {
                print_usage();
                return 0;
            }
            print_usage();
            println("");
            println("Error: ${err->message}");
            2;
        }
    };
}
