// Example demonstrating error types in BeamLang
// Error types can be used as the Err type parameter in Result<Ok, Err>

// Define custom error types
error FileError {
    path: String,
    message: String
}

error ParseError {
    line: number,
    message: String
}

// A function that returns a Result with a custom error type
fn parse_number(s: String) -> Result<number, ParseError> {
    // For this example, just return an error
    // In real code, this would parse the string
    return !err { line = 1, message = "Invalid number format" };
}

// A function that demonstrates error handling
fn process_file(path: String) -> Result<String, FileError> {
    // Simulating a file operation that could fail
    if (path == "") {
        return !err { path = path, message = "Empty path provided" };
    }
    return !ok "File content here";
}

fn main(args: [String]) -> number {
    // Test parse_number with error
    let result1 = parse_number("abc");
    match (result1) {
        case!ok value => println("Parsed: ${value}"),
        case!err err => println("Parse error at line ${err->line}: ${err->message}")
    };
    
    // Test process_file with error
    let result2 = process_file("");
    match (result2) {
        case!ok content => println("Content: ${content}"),
        case!err err => println("File error for '${err->path}': ${err->message}")
    };
    
    // Test process_file with success
    let result3 = process_file("test.txt");
    match (result3) {
        case!ok content => println("Content: ${content}"),
        case!err err => println("File error for '${err->path}': ${err->message}")
    };
    
    return 0;
}
