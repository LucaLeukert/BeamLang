// Example demonstrating internal fields in type definitions
// Internal fields can be accessed within method functions of the same type

type Counter {
    internal count: number,
    get: fn(Counter) -> number,
    increment: fn(Counter) -> Counter,
    add: fn(Counter, Counter) -> Counter
}

// Method function that accesses internal field via self
fn counter_get(self: Counter) -> number {
    // This works because we access via 'self'
    return self->count;
}

// Method function that creates a new Counter with updated internal field
fn counter_increment(self: Counter) -> Counter {
    let new_count = self->count + 1;
    return { count = new_count, get = counter_get, increment = counter_increment, add = counter_add };
}

// Method that accesses internal field of another Counter instance
// This works because we're inside a method of the same type
fn counter_add(self: Counter, other: Counter) -> Counter {
    // Accessing other->count is allowed because we're in a Counter method
    let new_count = self->count + other->count;
    return { count = new_count, get = counter_get, increment = counter_increment, add = counter_add };
}

fn counter_new(initial: number) -> Counter {
    return { count = initial, get = counter_get, increment = counter_increment, add = counter_add };
}

fn main(args: [String]) -> number {
    let c1 = counter_new(1);
    let c2 = counter_new(2);
    
    // Add two counters together - this accesses other->count internally
    let c3 = c1->add(c2);
    
    // Access the count through the get method (allowed)
    let value = c3->get();
    
    // Direct access like c3->count would be a compile error:
    // "Field 'count' is internal and cannot be accessed directly."
    
    return value; // Returns 3
}
