import lexer.*;
import token.*;

@external(elixir, "BeamLang.Runtime", "file_read")
fn file_read_data(path: String) -> String!String;

@external(elixir, "BeamLang.Runtime", "read_stdin")
fn read_stdin_data() -> String;

fn main(args: [String]) -> number {
    if (args->length() == 0) {
        print_help();
        return 0;
    }

    let cmd = args->get(0)->unwrap("");

    if (str_eq(cmd, "--help")) {
        print_help();
        return 0;
    }

    if (str_eq(cmd, "--version")) {
        println("selfhost 0.1.0");
        return 0;
    }

    if (str_eq(cmd, "lex") == false) {
        println("Error: unknown command");
        print_help();
        return 1;
    }

    if (args->length() != 2) {
        println("Error: lex expects exactly one argument: <file> or --stdin");
        return 1;
    }

    let target = args->get(1)->unwrap("");
    if (str_eq(target, "--stdin")) {
        let source = read_stdin_data();
        return lex_and_print(source);
    }

    let read_result = file_read_data(target);
    return match (read_result) {
        case!ok source => lex_and_print(source),
        case!err err -> {
            println("Error: ${err}");
            return 1;
        }
    };
}

internal fn print_help() -> void {
    println("Usage:");
    println("  selfhost --help");
    println("  selfhost --version");
    println("  selfhost lex <file>");
    println("  selfhost lex --stdin");
    return;
}

internal fn lex_and_print(source: String) -> number {
    let result = lex(source);

    return match (result) {
        case!ok tokens -> {
            print_tokens(tokens);
            return 0;
        },
        case!err err -> {
            println("LEX_ERROR ${err->message} ${to_string(err->line)}:${to_string(err->col)}");
            return 1;
        }
    };
}

internal fn print_tokens(tokens: [Token]) -> void {
    print_tokens_rec(tokens, 0);
    return;
}

internal fn print_tokens_rec(tokens: [Token], idx: number) -> void {
    if (idx >= tokens->length()) {
        return;
    }

    let token_opt = tokens->get(idx);
    match (token_opt) {
        case?some token -> {
            println("${token->kind} ${escape_for_line(token->value)} ${to_string(token->line)}:${to_string(token->col)}");
            print_tokens_rec(tokens, idx + 1);
            return;
        },
        case?none -> {
            return;
        }
    };
}

internal fn escape_for_line(value: String) -> String {
    let escaped_backslash = value->replace("\\", "\\\\");
    let escaped_newline = escaped_backslash->replace("\n", "\\n");
    let escaped_quote = escaped_newline->replace("\"", "\\\"");
    return escaped_quote;
}

internal fn str_eq(left: String, right: String) -> bool {
    if (left->length() != right->length()) {
        return false;
    }
    return left->starts_with(right);
}
