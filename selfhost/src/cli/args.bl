import args.*;

export type CliParsedArgs {
    mode: String,
    value: String
}

type CliFlags {
    @flag
    @short("h")
    @long("help")
    help: bool,

    @flag
    @long("version")
    version: bool,

    @flag
    @long("stdin")
    stdin: bool,

    @default("")
    command: String,

    @default("")
    target: String
}

internal fn parsed_args_new(mode: String, value: String) -> CliParsedArgs {
    return {
        mode = mode,
        value = value
    };
}

export fn parse_cli(argv: [String]) -> CliParsedArgs!String {
    let parsed = parse_args<CliFlags>(argv);

    return match (parsed) {
        case!ok flags => parse_with_flags(argv, flags),
        case!err err => parse_fallback(argv, err->message)
    };
}

export fn cli_help_text() -> String {
    return usage<CliFlags>("selfhost") + "\nCommands:\n  lex <file>\n  lex --stdin";
}

internal fn parse_with_flags(argv: [String], flags: CliFlags) -> CliParsedArgs!String {
    let positional = positional_args(argv);
    let command = positional->get(0)->unwrap("");
    let target = positional->get(1)->unwrap("");
    let count = positional->length();

    if (flags->help) {
        if (count > 0) {
            return !err "--help does not take extra arguments";
        }
        if (flags->stdin) {
            return !err "--help does not take extra arguments";
        }
        if (flags->version) {
            return !err "--help does not take extra arguments";
        }
        return !ok parsed_args_new("help", "");
    }

    if (flags->version) {
        if (count > 0) {
            return !err "--version does not take extra arguments";
        }
        if (flags->stdin) {
            return !err "--version does not take extra arguments";
        }
        return !ok parsed_args_new("version", "");
    }

    if (count == 0) {
        if (flags->stdin) {
            return !err "--stdin requires the lex command";
        }
        return !ok parsed_args_new("help", "");
    }

    if (str_eq(command, "lex")) {
        if (flags->stdin) {
            if (count > 1) {
                return !err "lex --stdin does not take a file path";
            }
            return !ok parsed_args_new("lex_stdin", "");
        }

        if (count != 2) {
            return !err "lex expects exactly one argument: <file> or --stdin";
        }

        return !ok parsed_args_new("lex_file", target);
    }

    return !err "unknown command";
}

internal fn parse_err_to_result(message: String) -> CliParsedArgs!String {
    if (message->contains("--help")) {
        return !ok parsed_args_new("help", "");
    }
    return !err message;
}

internal fn parse_fallback(argv: [String], message: String) -> CliParsedArgs!String {
    if (message->contains("--help")) {
        return !ok parsed_args_new("help", "");
    }

    let help = has_help_flag(argv);
    if (help) {
        if (argv->length() == 1) {
            return !ok parsed_args_new("help", "");
        }
        return !err "--help does not take extra arguments";
    }

    let version = find_flag(argv, "version", "");
    if (version) {
        if (argv->length() == 1) {
            return !ok parsed_args_new("version", "");
        }
        return !err "--version does not take extra arguments";
    }

    let stdin = find_flag(argv, "stdin", "");
    let positional = positional_args(argv);
    let command = positional->get(0)->unwrap("");
    let target = positional->get(1)->unwrap("");
    let count = positional->length();

    if (count == 0) {
        if (stdin) {
            return !err "--stdin requires the lex command";
        }
        return !ok parsed_args_new("help", "");
    }

    if (str_eq(command, "lex")) {
        if (stdin) {
            if (count > 1) {
                return !err "lex --stdin does not take a file path";
            }
            return !ok parsed_args_new("lex_stdin", "");
        }

        if (count != 2) {
            return !err "lex expects exactly one argument: <file> or --stdin";
        }

        return !ok parsed_args_new("lex_file", target);
    }

    return !err "unknown command";
}

internal fn str_eq(left: String, right: String) -> bool {
    if (left->length() != right->length()) {
        return false;
    }
    return left->starts_with(right);
}
